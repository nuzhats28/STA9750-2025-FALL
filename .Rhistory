fillOpacity = 0.5,
popup = ~paste("Species:", genusspecies,
"<br>Condition:", tpcondition),
clusterOptions = markerClusterOptions()) %>%
setView(lng = -73.94, lat = 40.70, zoom = 10) %>%
addLegend(position = "bottomright",
colors = "forestgreen",
labels = "Trees",
title = "NYC Trees")
nycc_districts
library(sf)
library(leaflet)
# Load shapefile
nycc_districts <- st_read("data/nycc_2021.shp")
list.files("data")
library(sf)
library(tidyverse)
# Create data directory if needed
if (!dir.exists("data/mp03")) {
dir.create("data/mp03", recursive = TRUE)
}
# Define file paths
zip_path <- "data/mp03/nycc.zip"
unzip_dir <- "data/mp03/nycc_shp"
# Updated NYC Planning Council District shapefile URL (2025)
url_primary <- "https://data.cityofnewyork.us/download/gqij-kd3p/application/zip"
library(sf)
library(dplyr)
# Create data directory
if (!dir.exists("data/mp03")) {
dir.create("data/mp03", recursive = TRUE)
}
# File paths
geojson_path <- "data/mp03/nycc_districts.geojson"
# Official download URL (GeoJSON version) for City Council Districts
url_primary <- "https://services5.arcgis.com/GfwWNkhOj9bNBqoJ/ArcGIS/rest/services/NYC_City_Council_Districts/FeatureServer/0/query?where=1%3D1&outFields=*&outSR=4326&f=geojson"
# Download if not already present
if (!file.exists(geojson_path)) {
message("‚¨áÔ∏è Downloading NYC City Council boundaries (GeoJSON)...")
download.file(url_primary, destfile = geojson_path, mode = "wb")
} else {
message("‚úÖ GeoJSON file already exists ‚Äî skipping download.")
}
# Read the GeoJSON into an sf object
message("üìñ Reading NYC City Council GeoJSON file...")
nycc_districts <- st_read(geojson_path, quiet = TRUE)
# Transform CRS to WGS84 (lat/long)
nycc_districts <- st_transform(nycc_districts, crs = "WGS84")
# Rename the column 'CounDist' ‚Üí 'coun_dist' for consistency
nycc_districts <- nycc_districts %>%
rename(coun_dist = CounDist)
# Optional: simplify geometry for faster plotting (especially if dataset is large)
nycc_districts <- nycc_districts %>%
mutate(geometry = st_simplify(geometry, dTolerance = 5))
# Preview the data
message("‚úÖ Data loaded and transformed successfully!")
print(nycc_districts %>% select(coun_dist) %>% head())
# Quick plot to verify boundaries
plot(st_geometry(nycc_districts),
main = "NYC City Council District Boundaries (Simplified)",
col = "lightgreen",
border = "gray40")
# ----------------------------------------------------------------------------
# Task 2: Download & Read NYC Tree Points
# ----------------------------------------------------------------------------
library(httr2)
library(sf)
library(dplyr)
# Create directory if needed
dir.create("data/mp03", recursive = TRUE, showWarnings = FALSE)
# Base API URL (GeoJSON endpoint)
base_url <- "https://data.cityofnewyork.us/resource/hn5i-inap.geojson"
# Parameters
limit <- 50000   # number of rows per request (adjustable)
offset <- 0      # starting row
page <- 1        # page counter
tree_files <- c()  # list to store downloaded files
repeat {
# File path for this page
file_path <- sprintf("data/mp03/tree_points_%03d.geojson", page)
# Skip download if file exists
if (!file.exists(file_path)) {
message(sprintf("‚¨áÔ∏è Downloading trees %d to %d...", offset + 1, offset + limit))
# API request with limit & offset
req <- request(base_url) %>%
req_url_query(`$limit` = limit, `$offset` = offset)
# Fetch data and save
resp <- req_perform(req)
writeBin(resp$body, file_path)
} else {
message(sprintf("‚úÖ File %s already exists ‚Äî skipping.", file_path))
}
# Read the GeoJSON page
trees_page <- st_read(file_path, quiet = TRUE)
# Store in list
tree_files <- append(tree_files, list(trees_page))
# If fewer than limit returned, we reached the end
if (nrow(trees_page) < limit) break
# Prepare next page
offset <- offset + limit
page <- page + 1
}
# Combine all pages into one sf object
nyc_trees <- bind_rows(tree_files)
# Optional: preview
message("‚úÖ NYC Tree Points downloaded and combined successfully!")
print(nyc_trees %>% slice_head(n = 5))
# ----------------------------------------------------------------------------
# Task 2: Download & Read NYC Tree Points
# ----------------------------------------------------------------------------
library(httr2)
library(sf)
library(dplyr)
# Create directory if needed
dir.create("data/mp03", recursive = TRUE, showWarnings = FALSE)
# Base API URL (GeoJSON endpoint)
base_url <- "https://data.cityofnewyork.us/resource/hn5i-inap.geojson"
# Parameters
limit <- 50000   # number of rows per request (adjustable)
offset <- 0      # starting row
page <- 1        # page counter
tree_files <- c()  # list to store downloaded files
repeat {
# File path for this page
file_path <- sprintf("data/mp03/tree_points_%03d.geojson", page)
# Skip download if file exists
if (!file.exists(file_path)) {
message(sprintf("‚¨áÔ∏è Downloading trees %d to %d...", offset + 1, offset + limit))
# API request with limit & offset
req <- request(base_url) %>%
req_url_query(`$limit` = limit, `$offset` = offset)
# Fetch data and save
resp <- req_perform(req)
writeBin(resp$body, file_path)
} else {
message(sprintf("‚úÖ File %s already exists ‚Äî skipping.", file_path))
}
# Read the GeoJSON page
trees_page <- st_read(file_path, quiet = TRUE)
# Store in list
tree_files <- append(tree_files, list(trees_page))
# If fewer than limit returned, we reached the end
if (nrow(trees_page) < limit) break
# Prepare next page
offset <- offset + limit
page <- page + 1
}
# Combine all pages into one sf object
nyc_trees <- bind_rows(tree_files)
# Optional: preview
message("‚úÖ NYC Tree Points downloaded and combined successfully!")
print(nyc_trees %>% slice_head(n = 5))
# ----------------------------------------------------------------------------
# Task 3: Map NYC Trees over City Council Districts
# ----------------------------------------------------------------------------
library(ggplot2)
library(sf)
# Ensure datasets are in the same CRS
nyc_trees <- st_transform(nyc_trees, st_crs(nycc_districts))
# Optional: for faster plotting, sample a subset of trees
# Comment out slice_sample for full dataset
trees_sample <- nyc_trees %>% slice_sample(n = 50000)  # 50k points
# Plot
ggplot() +
# Council district boundaries layer
geom_sf(data = nycc_districts, fill = NA, color = "black", size = 0.4) +
# Tree points layer
geom_sf(data = trees_sample, aes(), color = "forestgreen", size = 0.5, alpha = 0.3) +
# Titles and labels
labs(title = "NYC Tree Points Over City Council Districts",
subtitle = "Sample of 50,000 trees for visualization clarity",
caption = "Data Source: NYC OpenData") +
theme_minimal()
# Load libraries
library(sf)
library(dplyr)
# Ensure CRS is consistent
nyc_trees <- st_transform(nyc_trees, st_crs(nycc_districts))
# Spatial join: assign each tree to its district
trees_with_district <- st_join(nyc_trees, nycc_districts, join = st_within)
tree_counts <- trees_with_district %>%
st_drop_geometry() %>%
group_by(coun_dist) %>%
summarise(tree_count = n()) %>%
arrange(desc(tree_count))
most_trees_district <- tree_counts$coun_dist[1]
most_trees_count <- tree_counts$tree_count[1]
message(sprintf("District with most trees: %s (%d trees)",
most_trees_district, most_trees_count))
trees_density <- trees_with_district %>%
st_drop_geometry() %>%
group_by(coun_dist, Shape__Area) %>%
summarise(tree_count = n(), .groups = "drop") %>%
mutate(density = tree_count / Shape__Area) %>%
arrange(desc(density))
highest_density_district <- trees_density$coun_dist[1]
highest_density <- trees_density$density[1]
message(sprintf("District with highest tree density: %s (%.4f trees per m¬≤)",
highest_density_district, highest_density))
dead_fraction <- trees_with_district %>%
st_drop_geometry() %>%
group_by(coun_dist) %>%
summarise(
total = n(),
dead = sum(tolower(tpcondition) == "dead", na.rm = TRUE),
.groups = "drop"
) %>%
mutate(dead_frac = dead / total) %>%
arrange(desc(dead_frac))
highest_dead_district <- dead_fraction$coun_dist[1]
highest_dead_fraction <- dead_fraction$dead_frac[1]
message(sprintf("District with highest fraction of dead trees: %s (%.2f%%)",
highest_dead_district, highest_dead_fraction*100))
# Add borough column based on district
trees_with_district <- trees_with_district %>%
mutate(borough = case_when(
coun_dist %in% 1:10 ~ "Manhattan",
coun_dist %in% 11:18 ~ "Bronx",
coun_dist %in% 19:32 ~ "Queens",
coun_dist %in% 33:48 ~ "Brooklyn",
coun_dist %in% 49:51 ~ "Staten Island",
TRUE ~ NA_character_
))
most_common_manhattan_species <- trees_with_district %>%
filter(borough == "Manhattan") %>%
st_drop_geometry() %>%
group_by(genusspecies) %>%
summarise(n = n(), .groups = "drop") %>%
arrange(desc(n)) %>%
slice(1) %>%
pull(genusspecies)
message(sprintf("Most common tree species in Manhattan: %s", most_common_manhattan_species))
# Function to create an sf point for Baruch College
new_st_point <- function(lat, lon, ...) {
st_sfc(st_point(c(lon, lat)), crs = 4326)
}
# Baruch College coordinates: 40.7397 N, -73.9835 W
baruch_point <- new_st_point(40.7397, -73.9835)
# Compute distance from each tree to Baruch College and find the closest
closest_tree <- trees_with_district %>%
mutate(distance = st_distance(geometry, baruch_point)) %>%
arrange(distance) %>%
slice(1) %>%
st_drop_geometry()
closest_species <- closest_tree$genusspecies
message(sprintf("Species of tree closest to Baruch College: %s", closest_species))
# Filter Queens district (example: District 25 in Queens)
queens_district <- trees_with_district %>% filter(coun_dist == 25)
# Filter for London Plane trees
plane_trees <- queens_district %>% filter(genusspecies == "Platanus √ó acerifolia")
library(ggplot2)
ggplot() +
geom_sf(data = nycc_districts %>% filter(coun_dist == 25), fill = "lightgreen", color = "darkgreen") +
geom_sf(data = plane_trees, aes(color = genusspecies), size = 0.8, alpha = 0.7) +
labs(title = "London Plane Trees in Queens District 25",
subtitle = "Proposed tree planting project",
color = "Tree Species") +
theme_minimal()
library(stringr)
# Compare number of London Plane trees across 4 Queens districts
comparison_districts <- trees_with_district %>%
filter(coun_dist %in% c(25, 24, 23, 26)) %>%  # Queens districts
st_drop_geometry() %>%
group_by(coun_dist) %>%
summarise(
total_plane = sum(str_detect(tolower(genusspecies), "platanus"), na.rm = TRUE),
.groups = "drop"
)
# Bar chart
ggplot(comparison_districts, aes(x = factor(coun_dist), y = total_plane, fill = factor(coun_dist))) +
geom_col() +
labs(title = "London Plane Trees Across Selected Queens Districts",
x = "District",
y = "Number of Trees") +
theme_minimal() +
theme(legend.position = "none")
# Another Queens district for comparison (e.g., District 24)
other_district <- nycc_districts %>% filter(coun_dist == 24)
ggplot() +
geom_sf(data = other_district, fill = "lightblue", color = "darkblue") +
geom_sf(data = nycc_districts %>% filter(coun_dist == 25), fill = NA, color = "red", size = 1) +
geom_sf(data = plane_trees, aes(color = genusspecies), size = 0.8, alpha = 0.7) +
labs(title = "London Plane Trees: District 25 vs District 24") +
theme_minimal()
list.files("data")
list.files("data/mp03")
# Load required packages
library(sf)       # for spatial data
library(leaflet)  # for interactive maps
# Step 1: Load the NYC City Council districts GeoJSON
nycc_districts <- st_read("data/mp03/nycc_districts.geojson")
# Optional: inspect the data
print(nycc_districts)
class(nycc_districts)  # should show "sf"
# Step 2: Simplify polygons (optional, makes map lighter/faster)
nycc_districts_simple <- st_simplify(nycc_districts, dTolerance = 50)
# Step 3: Create the interactive map
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%  # base map
addPolygons(
data = nycc_districts_simple,
color = "darkgreen",     # district borders
weight = 0.5,            # thinner lines
fillOpacity = 0.1        # lighter fill
) %>%
addLegend(
position = "bottomright",
colors = "darkgreen",
labels = "NYC Council Districts",
opacity = 0.7
)
getwd()
library(quarto)   # to render the document
library(sf)       # for spatial data
library(leaflet)  # for interactive maps
library(dplyr)    # for data manipulation
# NYC Council districts
nycc_districts <- st_read("data/mp03/nycc_districts.geojson")
# Load and combine all tree GeoJSON files
tree_files <- list.files("data/mp03", pattern = "tree_points_.*\\.geojson$", full.names = TRUE)
trees_with_district <- do.call(rbind, lapply(tree_files, st_read))
# Step 1: Set working directory
setwd("/Users/nuzhatshahriyar/STA9750-2025-FALL")
# Step 2: Load packages
library(quarto)
library(sf)
library(leaflet)
library(dplyr)
# Step 3: Read NYC Council districts
nycc_districts <- st_read("data/mp03/nycc_districts.geojson")
# Step 4: Read all tree GeoJSON files
tree_files <- list.files("data/mp03", pattern = "tree_points_.*\\.geojson$", full.names = TRUE)
trees_all <- do.call(rbind, lapply(tree_files, st_read))
# Step 5: Reduce the number of points (sample 10% to make the HTML smaller)
set.seed(123)  # for reproducibility
trees_sample <- trees_all %>% slice_sample(prop = 0.1)
# Optional: add district info if needed
# trees_with_district <- st_join(trees_sample, nycc_districts, join = st_within)
# Step 6: Save the reduced data to a new file (optional, but safer)
st_write(trees_sample, "data/mp03/trees_sample.geojson", delete_dsn = TRUE)
# Step 7: Render the Quarto document
quarto::quarto_render("mp03.qmd")
# Step 8: Open locally to verify
browseURL("docs/mp03.html")
file.info("docs/mp03.html")$size / 1024^2  # size in MB
system("git status")
system("git add mp03.qmd docs/mp03.html")
system("git commit -m 'Render MP03 for GitHub Pages'")
system("git push origin main")
library(ggplot2)
library(dplyr)
library(sf)
# Sample trees to reduce size
plane_trees_sample <- plane_trees %>% sample_frac(0.05)
# Select districts
district_25 <- nycc_districts %>% filter(coun_dist == 25)
# Another Queens district for comparison (e.g., District 24)
other_district <- nycc_districts %>% filter(coun_dist == 24)
library(dplyr)
library(ggplot2)
library(sf)
# Simplify for smaller file size
nycc_districts_small <- nycc_districts %>% filter(coun_dist %in% c(24, 25))
names(nycc_districts)
# Filter districts correctly
districts_small <- nycc_districts %>% filter(CounDist %in% c(24, 25))
ggplot() +
geom_sf(data = districts_small %>% filter(CounDist == 24),
fill = "lightblue", color = "darkblue") +
geom_sf(data = districts_small %>% filter(CounDist == 25),
fill = NA, color = "red", size = 1) +
geom_sf(data = trees_sample, aes(color = genusspecies),
size = 0.8, alpha = 0.7) +
labs(title = "London Plane Trees: District 25 vs District 24") +
theme_minimal()
# Another Queens district for comparison (e.g., District 24)
other_district <- nycc_districts %>% filter(coun_dist == 24)
# Another Queens district for comparison (e.g., District 24)
other_district <- nycc_districts %>% filter(CounDist == 24)
ggplot() +
geom_sf(data = other_district, fill = "lightblue", color = "darkblue") +
geom_sf(data = nycc_districts %>% filter(CounDist == 25), fill = NA, color = "red", size = 1) +
geom_sf(data = plane_trees, aes(color = genusspecies), size = 0.8, alpha = 0.7) +
labs(title = "London Plane Trees: District 25 vs District 24") +
theme_minimal()
names(nycc_districts)
library(sf)
library(dplyr)
library(ggplot2)
# Load shapefile (adjust path if needed)
nycc_districts <- st_read("data/nycc_2021.shp")
getwd()
list.files("data")
# Another Queens district for comparison (e.g., District 24)
other_district <- nycc_districts %>% filter(coun_dist == 24)
# Install quarto if you haven't already
# install.packages("quarto") # optional if not installed
# Render the qmd file
quarto::quarto_render("mp03.qmd")
# 1. Render the Quarto document
quarto::quarto_render("mp03.qmd", output_file = "docs/mp03.html")
quarto::quarto_render("your_document.qmd")
# Add the new files
git add mp03.qmd docs/mp03.html _quarto.yml
quarto::quarto_check()
# Tell Git to store credentials permanently
system("git config --global credential.helper store")
# Make sure Quarto is installed first
# install.packages("quarto")  # run if needed
# Render mp03.qmd
quarto::quarto_render("mp03.qmd")
''''''''''''''''''''''''''''
# Add files
system("git add mp03.qmd docs/mp03.html _quarto.yml")
# Commit changes
system('git commit -m "Publish mp03.qmd to GitHub Pages"')
# Push to GitHub
system("git push origin main")
# =========================
# 1Ô∏è‚É£ Configure Git to store credentials (first time only)
# =========================
system("git config --global credential.helper store")
# =========================
# 2Ô∏è‚É£ Ensure docs/ folder exists
# =========================
if (!dir.exists("docs")) dir.create("docs")
# =========================
# 3Ô∏è‚É£ Update mp03.qmd YAML to use lightweight HTML
# =========================
# Make sure your mp03.qmd has at the top:
# format:
#   html:
#     self-contained: false
# If not, you can add this manually before running the script.
# =========================
# 4Ô∏è‚É£ Render mp03.qmd into docs/mp03.html
# =========================
if (!requireNamespace("quarto", quietly = TRUE)) install.packages("quarto")
quarto::quarto_render(
input = "mp03.qmd",
output_file = "docs/mp03.html"
)
# =========================
# 1Ô∏è‚É£ Configure Git to store credentials (first time only)
# =========================
system("git config --global credential.helper store")
# =========================
# 2Ô∏è‚É£ Ensure docs/ folder exists
# =========================
if (!dir.exists("docs")) dir.create("docs")
# =========================
# 3Ô∏è‚É£ Render mp03.qmd (lightweight HTML)
# =========================
if (!requireNamespace("quarto", quietly = TRUE)) install.packages("quarto")
quarto::qua
# 1Ô∏è‚É£ Configure Git credential helper (once)
system("git config --global credential.helper store")
# 2Ô∏è‚É£ Ensure docs/ folder exists
if (!dir.exists("docs")) dir.create("docs")
# 3Ô∏è‚É£ Render mp03.qmd via Quarto CLI
system("quarto render mp03.qmd")
# 4Ô∏è‚É£ Move HTML if not automatically in docs/
if (!file.exists("docs/mp03.html") && file.exists("mp03.html")) {
file.rename("mp03.html", "docs/mp03.html")
}
# 5Ô∏è‚É£ Copy figure folders (e.g., mp03_files, assets)
fig_folders <- c("mp03_files", "assets")
for (f in fig_folders) {
if (dir.exists(f)) {
dest <- file.path("docs", f)
if (!dir.exists(dest)) dir.create(dest, recursive = TRUE)
file.copy(list.files(f, full.names = TRUE), dest, recursive = TRUE)
}
}
# 6Ô∏è‚É£ Ignore large data files
gitignore_file <- ".gitignore"
large_files <- c("data/mp03/trees_sample.geojson")
for (f in large_files) {
if (!file.exists(gitignore_file)) file.create(gitignore_file)
if (!any(readLines(gitignore_file) == f)) {
write(f, file = gitignore_file, append = TRUE)
}
}
# 7Ô∏è‚É£ Add files to Git
system("git add mp03.qmd docs/mp03.html _quarto.yml .gitignore docs/mp03_files docs/assets")
# 8Ô∏è‚É£ Commit changes
system('git commit -m "Render MP03 using CLI, skip large data"')
# 9Ô∏è‚É£ Push to GitHub
system("git push origin main")
cat("\nYour MP03 page should now be live at:\n")
cat("https://nuzhats28.github.io/STA9750-2025-FALL/mp03.html\n")
list.files("docs")
# Add the files to Git
system("git add docs/mp03.html docs/mp03_files")
system('git commit -m "Add MP03 HTML and figures"')
# Add the HTML and all figure folders
system("git add docs/mp03.html docs/mp03_files")
# Check status to make sure everything is staged
system("git status")
# Commit all changes
system('git commit -m "Add complete MP03 HTML and all figures"')
# Push to GitHub
system("git push origin main")
echo "data/mp03/trees_sample.geojson" >> .gitignore
# Add large file to .gitignore
system('echo "data/mp03/trees_sample.geojson" >> .gitignore')
# Remove it from Git tracking (but keep locally)
system("git rm --cached data/mp03/trees_sample.geojson")
# Commit the removal
system('git commit -m "Remove large data from repo"')
system("quarto render mp03.qmd")
file.rename("mp03.html", "docs/mp03.html")
