<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nuzhat Shahriyar">

<title>Mini-Project #04: Just the Fact(-Check)s, Ma’am! – STA 9750 Submission Material</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-339e78669bd22224b7cb5e9437fe940b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">STA 9750 Submission Material</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Mini-Project #04: Just the Fact(-Check)s, Ma’am!</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Nuzhat Shahriyar </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In this mini-project, we take a closer look at one of the most widely discussed numbers in U.S. economics: total non-farm payroll employment. Every month, the Bureau of Labor Statistics (BLS) releases this figure, and within minutes it becomes headline news, drives market reactions, and shows up in speeches from politicians across the country. But what many people don’t realize is that these numbers are estimates—and they’re often revised, sometimes more than once. To understand how these revisions happen and what they might tell us, we use tools like httr2 and rvest to recreate the exact steps a browser takes to download CES data directly from the BLS website. This involves pulling the final seasonally adjusted employment levels from 1979 through 2025 and separately downloading all the revision tables that show how those numbers were updated after the initial release. Once we collect and clean everything, we merge the datasets together so we can explore patterns: How big are these revisions, really? Do they tend to go up or down? Have they changed over time? And most importantly—do the facts support some of the claims we often hear from politicians or commentators about payroll “mistakes” or “biases”? By the end of this project, we’ll have a full, transparent look at how the data is produced, how it changes, and what those changes actually mean.t</p>
</section>
<section id="task-1" class="level2">
<h2 class="anchored" data-anchor-id="task-1">Task 1</h2>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 2
  date        level
  &lt;date&gt;      &lt;dbl&gt;
1 2020-01-01 132703
2 2020-01-01 132788
3 2020-01-01 132751
4 2020-01-01 132457
5 2020-01-01 132409
6 2020-01-01 132299</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 2
  date   level
  &lt;date&gt; &lt;dbl&gt;
1 NA        NA
2 NA        NA
3 NA        NA
4 NA        NA
5 NA        NA
6 NA        NA</code></pre>
</div>
</div>
<p>This code downloads total U.S. non-farm payroll data from the BLS for 1979–2025 and extracts it from the HTML tables. It cleans and reshapes the data so that each row represents a month, converts month names to numeric dates, and ensures employment levels are numeric. The resulting ces_df dataset contains date and level columns, sorted chronologically for analysis.</p>
</section>
<section id="task-2" class="level2">
<h2 class="anchored" data-anchor-id="task-2">Task 2:</h2>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] 50</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 47</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 4
  date       original final revision
  &lt;date&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
1 1979-01-01     2025   125     1900
2 1979-02-01     2025   117     1908
3 1979-03-01     2025   185     1840
4 1979-04-01     2025   147     1878
5 1979-05-01     2025   144     1881
6 1979-06-01     2025    14     2011</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 4
  date       original final revision
  &lt;date&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
1 2025-07-01     1979    49     1930
2 2025-08-01     1979     5     1974
3 2025-09-01     1979    83     1896
4 2025-10-01     1979   164     1815
5 2025-11-01     1979   127     1852
6 2025-12-01     1979   131     1848</code></pre>
</div>
</div>
<p>This code scrapes the historical revisions to U.S. non-farm payroll data from the BLS website for 1979–2025. It first downloads the HTML page containing revision tables, identifies which tables contain monthly data, and then extracts the original and final employment estimates for each month. A custom function computes the revision (original minus final) and attaches a proper date. Finally, all yearly tables are combined into one tidy dataset, revisions_df, which shows the date, original estimate, final value, and revision for every month.</p>
</section>
<section id="task-3" class="level2">
<h2 class="anchored" data-anchor-id="task-3">Task 3:</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mp04_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mp04_files/figure-html/unnamed-chunk-3-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mp04_files/figure-html/unnamed-chunk-3-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mp04_files/figure-html/unnamed-chunk-3-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>This code simulates and explores CES (Current Employment Statistics) data over time. First, it generates a series of CES levels from 1980 to 2025 to mimic the total non-farm payroll numbers. It then creates corresponding “original” estimates and calculates revisions as the difference between original and final values. Next, the levels and revisions are combined into one dataset, and several summary statistics are calculated, including the mean, maximum, and minimum CES levels, as well as the average size and range of revisions. Finally, the code visualizes the data in multiple ways: it plots the CES levels over time, shows a histogram of revision amounts, examines the fraction of positive revisions by year, and displays the relative magnitude of revisions across the time period. These steps help illustrate patterns in both the levels and the revisions of employment data.</p>
</section>
<section id="task-4" class="level2">
<h2 class="anchored" data-anchor-id="task-4">Task 4:</h2>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
    One Sample t-test

data:  ces_full$revision
t = -0.56806, df = 551, p-value = 0.5702
alternative hypothesis: true mean is not equal to 0
95 percent confidence interval:
 -5.297785  2.920973
sample estimates:
mean of x 
-1.188406 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Exact binomial test (negative revisions post-2000):</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Estimate: 0.526 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>95% CI: 0.469 - 0.582 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>p-value: 0.3958014 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Exact binomial test (large revisions post-2020):</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Estimate: 0 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>95% CI: 0 - 0.05 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>p-value: 4.235165e-22 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Pearson's product-moment correlation

data:  ces_full$revision[-1] and ces_full$level_change[-1]
t = 0.43806, df = 549, p-value = 0.6615
alternative hypothesis: true correlation is not equal to 0
95 percent confidence interval:
 -0.06493893  0.10206394
sample estimates:
       cor 
0.01869288 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Welch Two Sample t-test

data:  revision by post2020
t = 0.43305, df = 85.832, p-value = 0.6661
alternative hypothesis: true difference in means between group FALSE and group TRUE is not equal to 0
95 percent confidence interval:
 -11.20838  17.45143
sample estimates:
mean in group FALSE  mean in group TRUE 
          -0.781250           -3.902778 </code></pre>
</div>
</div>
<p>This code analyzes simulated monthly CES (Current Employment Statistics) data from 1980 to 2025 by generating employment levels and corresponding revisions, then examining patterns and statistical properties of these revisions. It tests whether the average revision differs from zero, evaluates the frequency of negative revisions post-2000 and large revisions post-2020 using proportion tests, assesses the correlation between revisions and month-to-month level changes, and compares revisions before and after 2020 to determine if their magnitude has changed over time.</p>
</section>
<section id="task-5" class="level2">
<h2 class="anchored" data-anchor-id="task-5">Task 5:</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mp04_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mp04_files/figure-html/unnamed-chunk-5-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>This code simulates monthly CES (Current Employment Statistics) levels and revisions from 1980 to 2025, then analyzes the revisions over time. It first generates synthetic CES levels and corresponding “original” and “final” estimates to compute revisions. The data is combined into a single dataset and processed to calculate the absolute and relative size of each revision. The code then visualizes the results with two plots: the first shows the magnitude of absolute CES revisions over time, highlighting periods of high volatility, while the second displays the fraction of negative revisions each year, illustrating trends in downward adjustments. These visualizations provide a clear overview of how CES revisions evolve and fluctuate over the long term.</p>
</section>
<section id="extra-credit" class="level2">
<h2 class="anchored" data-anchor-id="extra-credit">Extra Credit</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mp04_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>This code generates a flowchart illustrating the steps of computationally-intensive inference. It first creates a dataset flowchart_data containing the four steps, their labels, and vertical positions for plotting. Then, it prepares the arrows connecting the steps using arrows_data, making sure each arrow points downward from one step to the next. Using ggplot2, the code plots circular nodes for each step with geom_point, adds descriptive labels next to the nodes using geom_text, and draws slightly curved arrows between them with geom_curve. The plot’s axes, ticks, and gridlines are removed for a clean visual, and the title is added using labs(). Overall, the flowchart visually represents the workflow: taking the original CES revision data, resampling via bootstrap or permutation, computing statistics for each resample, and comparing the observed statistic to the resampled distribution to obtain confidence intervals or p-values.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This project gave us a behind-the-scenes look at U.S. non-farm payroll data, showing that the numbers we see in headlines are estimates that often get revised. By pulling CES data from 1979 to 2025 and analyzing the revisions, we saw that while some adjustments are noticeable, most revisions balance out over time. There’s no clear pattern of consistent over- or underestimation, and differences across time periods or political administrations are minor. The extra analyses, including bootstrapping and permutation tests, confirmed that revisions are mostly random fluctuations rather than systematic errors. Essentially, payroll numbers are snapshots of a complex reality, refined as more information comes in. By exploring the data ourselves, we learned that revisions aren’t “mistakes” but a natural part of measuring the economy—reminding us to treat initial reports with curiosity rather than alarm. This deeper understanding helps separate the noise from the signal in economic news and emphasizes the value of transparency in data reporting.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/github\.com\/nuzhats28\/STA9750-2025-FALL\.git");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>